/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== 'navigate') {
            return false;
        } // If this is a URL that starts with /_, skip.

        if (url.pathname.startsWith('/_')) {
            return false;
        } // If this looks like a URL for a resource, because it contains // a file extension, skip.

        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        } // Return true to signal that we want to use the handler.

        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
    // Add in any other file extensions or routing criteria as needed.
    ({ url }) =>
        url.origin === self.location.origin && url.pathname.endsWith('.png'), // Customize this strategy as needed, e.g., by changing to CacheFirst.
    new StaleWhileRevalidate({
        cacheName: 'images',
        plugins: [
            // Ensure that once this runtime cache reaches a maximum size the
            // least-recently used images are removed.
            new ExpirationPlugin({ maxEntries: 50 }),
        ],
    })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting();
    }
});

// Any other custom service worker logic can go here.
// registerRoute(
//     ({ url }) =>
//         (url.origin =
//             'https://rickandmortyapi.com' &&
//             (url.pathname.endsWith('.jpeg') || url.pathname.endsWith('jpg'))),
//     new StaleWhileRevalidate({
//         cacheName: 'avatar-cache',
//         plugins: [
//             new ExpirationPlugin({
//                 maxEntries: 20,
//                 maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
//             }),
//         ],
//     })
// );
registerRoute(
    // --------------------Match callback---------------------------
    // ({ request, url, event, sameOrigin }) => {
    //     console.log('Request', request);
    //     console.log('Url', url);
    //     console.log('Event', event);
    //     return (
    //         url === 'https://rickandmortyapi.com/api/character/avatar/1.jpeg'
    //     );
    // },
    // --------------------------------------------------------
    // -----------------------Regular expression---------------------
    /https:\/\/rickandmortyapi\.com\/api\/character\/avatar\/(.+)\.(?:jpeg|jpg)/,
    //---------------------------------------------------------------
    new StaleWhileRevalidate({
        cacheName: 'avatar-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 20,
                maxAgeSeconds: 7 * 24 * 60 * 60, // 1 week
            }),
        ],
    })
);

//============================================Background sync for PATCH requests(Using Supabase for this example)======================================

// We use registerRoute and match the Supabase URL just like we did with the GET cache. Notice the third parameter for registerRoute is "PATCH" which differentiates this route from the other which defaults to "GET". For the handler we use the NetworkOnly strategy with the plugin BackgroundSyncPlugin to which we assign a day's worth of minutes to the option maxRetentionTime, which is self-explanatory.
// const bgSyncPlugin = new BackgroundSyncPlugin('PATCH-que', {
//     maxRetentionTime: 24 * 60,
// });

// registerRoute(
//     ({ url }) => {
//         return `https://${url.host}` === supabaseUrl;
//     },
//     new NetworkOnly({
//         plugins: [bgSyncPlugin],
//     }),
//     'PATCH'
// );

//===============================================================================================================================================

// =============================================Promting user for update of service worker========================================================

// COMPLEX SOLUTION
// https://dev.to/noconsulate/react-pwa-with-workbox-6dl 

// EASIER SOLUTION
// https://betterprogramming.pub/prompting-new-app-versions-with-the-service-worker-and-create-react-app-bf3350d3bed1 

// ===================================================================================================================================================